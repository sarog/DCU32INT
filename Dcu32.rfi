/*
This file describes the results of reverse engineering the DCU file format for
Delphi 2.0-8.0, 2005(.net and WIN32), 2006(WIN32 only), Kylix 1.0-3.0.
Note, that the FlexT file describes only the DCU memory layout aspects of file
format. The Pascal code for parsing DCUs (DCU32INT project) is published at
http://hmelnov.icc.ru/DCU/
*/

data
  0x0000 ulong Magic

%$IF Magic=0xF21F148C;
//Kylix1.0
const
  Ver=100;
descr ('Borland Kylix 1.0 unit file.')
%$ELSIF Magic=0x0E1011DD;
//Kylix2.0
const
  Ver=101;
descr ('Borland Kylix 2.0 unit file.')
%$ELSIF Magic=0x0E0001DD;
//Kylix2.0, another magic
const
  Ver=101;
descr ('Borland Kylix 2.0 unit file (kind $00).')
%$ELSIF (Magic=0x0F1001DD)or(Magic=0x0F0001DD);
//Kylix3.0
const
  Ver=102;
descr ('Borland Kylix 3.0 unit file.')

%$ELSIF Magic=0x12000023;
//Delphi10.0 - not completely tested yet
const
  Ver=10;
descr ('Borland Delphi 2006 unit file.')
%$ELSIF Magic=0x11000239;
//Delphi9.0
const
  Ver=9;
  MSIL=1;
descr ('Borland Delphi 2005 MSIL unit file.')
%$ELSIF (Magic=0x1100000D)or(Magic=0x11800009); //0x11800009 in DUnitMainForm.dcu
//Delphi9.0 - not completely tested yet
const
  Ver=9;
descr ('Borland Delphi 2005 unit file.')
%$ELSIF Magic=0x10000229;
//Delphi8.0 - not completely tested yet
const
  Ver=8;
  MSIL=1;
descr ('Borland Delphi 8.0 MSIL unit file.')
%$ELSIF Magic and 0xFF80FFFF=0xFF0000DF;
//Delphi7.0 - not completely tested yet
const
  Ver=7;
descr ('Borland Delphi 7.0 (Free) unit file.')
%$ELSIF Magic and 0xFF00FFFF=0x0F0000DF;
//Delphi7.0
const
  Ver=7;
descr ('Borland Delphi 7.0 unit file.')
%$ELSIF Magic and 0xFF80FFFF=0x0E0000DD;
//Delphi6.0
const
  Ver=6;
descr ('Borland Delphi 6.0 unit file.')
%$ELSIF Magic and 0xFF80FFFF=0x0E8000DD;
//Delphi6.0, another magic
const
  Ver=6;
descr ('Borland Delphi 6.0 unit file (kind $80).')
%$ELSIF Magic=0xF21F148B;
//Delphi5.0
const
  Ver=5;
descr ('Borland Delphi 5.0 unit file.')
%$ELSIF Magic=0x4768A6D8;
//Delphi4.0
const
  Ver=4;
descr ('Borland Delphi 4.0 unit file.')
%$ELSIF Magic=0x44518641; //'A†QD'
//Delphi3.0
const
  Ver=3;
descr ('Borland Delphi 3.0 unit file.')
%$ELSIF Magic=0x50505348; //HSPP
//Delphi2.0
const
  Ver=2;
descr ('Borland Delphi 2.0 unit file.')
%$ELSE
assert 0; //fail
%$END

%$IF not defined MSIL;
const
MSIL=0;
%$END

%$IF not defined Packaged;
const
Packaged=0;
%$END



descr (NL,
  'Info Src: Partially reconstructed by me (Alexei Hmelnov (mailto:alex@icc.ru)).',NL,
  'Info Src: DoDi''s DCU Documentation (mailto:VBDis@aol.com)',NL)

const
  IsKylix = Ver>=100;
  IsDelphi = Ver<100;
  gen7 = (Ver>=7) and IsDelphi or (Ver>=102);

type

TDCU30RecTag enum char (
  drStop=0,
  drStop_a='a', //Last Tag in all files
  drStop1='c',
  drUnit='d',
  drUnit1='e', //in implementation
  drImpType='f',
  drImpVal='g',
  drDLL='h',
  drExport='i',
  drEmbeddedProcStart='j',
  drEmbeddedProcEnd='k',
  drCBlock='l',
  drFixUp='m',
  drImpTypeDef='n', //import of type definition by "A = type B"
%$IF (Ver>=8)and IsDelphi;
  drORec='o', //goes before drCBlock
 %$IF (Ver>=10)and IsDelphi;
  drStrConstRec='6',
 %$ELSE
  drStrConstRec='5',
 %$END
%$END
  drSrc='p',
  drObj='q',
  drRes='r',
  drAsm='s', //Observed in D5
  drStop2='Ÿ', //!!!
  drConst=0x25, //'%',

 %$IF (Ver>=10)and IsDelphi;
  drThreadVar='2',
  drResStr='3',
 %$ELSE
  drThreadVar='1',
  drResStr='2',
 %$END

  drType='*',
  drTypeP='&',
  drProc='(',
  drSysProc=')',
  drVar=0x20 //' ',
  drVarC=0x27 //''',
  drAbsVar='$',
  drVoid='@',
  drLabel='+',
  drBoolRangeDef='A',
  drChRangeDef='B',
  drEnumDef='C',
  drRangeDef='D',
  drPtrDef='E',
  drClassDef='F',
  drObjVMTDef='G',
  drProcTypeDef='H',
  drFloatDef='I',
  drSetDef='J',
  drShortStrDef='K',
  drArrayDef='L',
  drRecDef='M',
  drObjDef='N',
  drFileDef='O',
  drTextDef='P',
  drWCharRangeDef='Q', //WideChar
  drStringDef='R',
  drVariantDef='S',
  drInterfaceDef='T',
  drWideStrDef='U',
  drWideRangeDef='V',
%$IF (Ver>=8)and IsDelphi;
  drMetaClassDef='W', //?? guess name
%$END
//Various tables
  drCodeLines=0x90,
  drLinNum=0x91,
  drStrucScope=0x92,
  drSymbolRef=0x93,
  drLocVarTbl=0x94,
  drUnitFlags=0x96,
%$IF IsKylix; //Kylix specific flags
 // drUnit3=0xE0, //4-bytes record, present in almost all units
 // drUnit3s=0x06, //3-bytes record, present in System and SysInit
  drUnit4=0x0F, //5-bytes record, was observed in QOpenBanner.dcu only
%$ELSIF Ver>=7;
 %$IF (Ver>=10)and IsDelphi;
  drUnitAddInfo='5',
 %$ELSE
  drUnitAddInfo='4',
 %$END
  drProcAddInfo=0x9E,
%$END
%$IF gen7;
  drConstAddInfo=0x9C, //caused by the "platform" keyword
%$END
%$IF (Ver>=8)and IsDelphi;
  drInfo98=0x98,
%$END
%$IF (Ver>=10)and IsDelphi;
//  drAddInfo6='6',
  drSpecVar='7',
  drCLine=0xA0,
  drA1Info=0xA1,
  drA2Info=0xA2,
%$END
  drSetDeft=0x9A //Set Default parameter value
)

type bit
  TBit num+(1)
  TBit4 num+(4)
  TBit7 num+(7)
  TBit8 num+(7)
  TBit14 num+(14)
  TBit21 num+(21)
  TBit28 num+(28)
  TBit32 num+(32)

  TNDXB1 struc pas
    IsW: TBit
    V: case @.IsW of
     0: TBit7
     else struc pas
       IsB3: TBit
       V: case @.IsB3 of
        0: TBit14
        else struc pas
          IsB4: TBit
          V: case @.IsB4 of
           0: TBit21
           else struc pas
             IsB5: TBit
             V: case @.IsB5 of
              0: TBit28
              else struc pas
                Z: TBit4
                V: case @.Z of
                  0: TBit32
                  else struc pas //0xF: Delphi 4.0 - 64 bit
                    Lo: TBit32
                    Hi: TBit32
                  ends: displ=(HEX(@.Hi),HEX(@.Lo))
                 endc: displ=((@.0)exc(@.0xF))
              ends
              endc:displ=((@.0)exc(@.1))
           ends
           endc:displ=((@.0)exc(@.1.V))
        ends
        endc:displ=((@.0)exc(@.1.V))
     ends
     endc:displ=((@.0)exc(@.1.V))
  ends:displ=('#',@.V):let Val=(@.V.0)exc((@.V.1.V.0)exc
      ((@.V.1.V.1.V.0)exc((@.V.1.V.1.V.1.V.0)exc
      (@.V.1.V.1.V.1.V.1.V/*4.0*/.0))));

/*
TFileTime struc pas
  S: num+(5)
  M: num+(6)
  H: num+(5)
  D: num+(5)
  Mon: num+(4)
  Y: num+(7)
ends:displ=(INT(@.D),'.',INT(@.Mon),'.',INT(@.Y+1980),' ',
      INT(@.H),':',INT(@.M),':',INT(@.S*2))
*/

%$IF IsDelphi;

include DOSFTime.rfi

%$ELSE

include UNIXTime.rfi

type

TFileTime TTimeStamp

%$END

type

TDCU30ListC forward

TSrcInf struc pas
  FT: TFileTime
  B: TNDXB1
%$IF MSIL;
  path: str
%$END
ends

%$IF (Ver>7)and IsDelphi;
TResInf struc pas
  FT: TFileTime
  B: TNDXB1
ends
%$ELSE
TResInf TSrcInf
%$END

TUnitInf struc pas
 %$IF (Ver>=8)and IsDelphi;
  hPack: TNDXB1
 %$END
 %$IF (Ver>=10)and IsDelphi;
  Inf: TNDXB1
 %$ELSE
  Inf: ulong
 %$END
%$IF (Ver=7)and IsDelphi;
  X: ulong
//%$ELSIF (Ver>=8)and IsDelphi;
//  X: byte
%$END
  L: TDCU30ListC
ends

%$IF (Ver>=8)and IsDelphi;
TDLLInf struc pas
 %$IF (Ver>=10)and IsDelphi;
  Inf: TNDXB1
 %$ELSE
  Inf: ulong
 %$END
  X: ulong
  L: TDCU30ListC
ends
%$ELSE
  TDLLInf TUnitInf
%$END


TImpTypeDefInf struc pas
  RTTISz: TNDXB1//L: Byte
  Inf: ulong
ends

TExportInf struc pas
  hSym: TNDXB1
  Index: TNDXB1
ends

TNameFDecl struc pas
  B: TNDXB1
%$IF (Ver>=8)and IsDelphi;
  B1: TNDXB1
%$END
  Inf: case @.B:Val and 0x40 of
    0x40: ulong
  endc
%$IF (Ver>=8)and IsDelphi;
  B2: case @.B1:Val and 0x80  of 
    0x80: struc pas
       X: TNDXB1 //Base type for defs like TX = type TY
        //when TX and TY both in the same unit, 
        //earlier versions were just duplicating definitions
 %$IF (Ver=8)and IsDelphi;
       Z: case @@@.B:Val and 0x08  of
        0x08: TNDXB1 //always 0
       endc
 %$END
     ends
  endc
%$END
ends

TTypeInf struc pas
  NF: TNameFDecl
  hDef: TNDXB1
%$IF Packaged;
  hPkg: TNDXB1
%$END
ends

TTypePInf struc pas
  NF: TNameFDecl
  hDef: TNDXB1
//  B1: Byte
  B1: TNDXB1
%$IF Packaged;
  hPkg: TNDXB1
%$END
ends

TVarInf struc pas
  NF: TNameFDecl
  hDT: TNDXB1
  Ofs: TNDXB1 //hDT: TNDXB1 //B0: Byte
ends

TConstVal struc pas
  Sz: TNDXB1
  Val: case (@.Sz.V.0)exc 1 of
    0: TNDXB1
  else raw[@@.Sz:Val]
  endc
ends

TConstDef struc pas
  NF: TNameFDecl
  //Inf: ulong
  hDT: TNDXB1
%$IF Ver>4;
  hX: TNDXB1
%$END
  Val: TConstVal
ends

/*
TResStrDef struc pas
  b80: Byte
  Inf: case @.b80 and 0x80 of
    0x80: ulong
  endc
  hDT: TNDXB1
  Ofs: TNDXB1
/*
  NDX1: TNDXB1
  B1: Byte
  B2: Byte
  V: TNDXB1
  Val: TConstVal
*/
ends
*/

TProcArgTag enum TDCU30RecTag (
  arStop='c',
  arVal='!',
  arVar='"',
  arResult='#',
  arAbsLocVar='$',
  arLabel='+',
  arLocVar=0x20,//' ',
  arConst=0x25, //'%',
  arLocType='*',
  arEmbeddedProcEnd='k', //For Ver 5.0
//Fields
  arFld=',',
 %$IF (Ver>=10)and IsDelphi;
  arClassVar='-',
  arMethod='.',
  arConstr='/',
  arDestr='0',
  arProperty='1',
 %$ELSE
  arMethod='-',
  arConstr='.',
  arDestr='/',
  arProperty='0',
 %$END
  arCDecl=0x81,
  arPascal=0x82,
  arStdCall=0x83,
  arSafeCall=0x84,
%$IF (Ver>=10)and IsDelphi;
  arCopyDecl=0xA3,
%$END
  arSetDeft=0x9A //Set Default parameter value
)

TPropInfo struc pas
  Flags: TNDXB1
 %$IF (Ver>=8)and IsDelphi;
  Flags1: TNDXB1
 %$END
  hDT: TNDXB1
  Ndx: TNDXB1
  hIndex: TNDXB1 //property index
/*  D0Fl0: ulong
  B80: Byte */
  hRead: TNDXB1
  hWrite: TNDXB1
  hStored: TNDXB1
/*  D0Fl1: ulong
  B80a: Byte */
 %$IF (Ver>=8)and IsDelphi;
  X: TNDXB1
  X1: TNDXB1
 %$IF MSIL;
  X2: TNDXB1
  X3: TNDXB1
 %$END
 %$END
  hDeft: TNDXB1
ends

TSetDeftInfo struc pas
  hConst: TNDXB1
  hArg: TNDXB1
/*  sdB0: Byte
  sdB1: Byte
  sdB2: Byte
  sdB3: Byte
*/
ends

//%$IF (Ver>=7)and IsDelphi;
%$IF gen7;

%$IF (Ver>=8)and IsDelphi;

TConstAddInfo01Rec struc pas
  hDef: TNDXB1
  V: TNDXB1
  Len: TNDXB1
  SD: case @.Len:Val>0 of
    1: struc pas
      Name: array[@@@.Len:Val]of Char
      Cnt: TNDXB1
      Defs: array[@.Cnt:Val] of TNDXB1
     ends
   endc
ends

TStrNDXB1 struc pas
  Len: TNDXB1
  V: array[@.Len:Val]of Char
ends


TConstAddInfo0A_7Rec struc pas
  Name: TStrNDXB1
  V: TNDXB1
  V1: TNDXB1
  hDT: TNDXB1
ends

TConstAddInfoRec struc pas
  Tag: Byte
  D: case @.Tag of
   0x01: struc pas
     hDef: TNDXB1
     F: TNDXB1 //$1-deprecated,$2-Platform,$80000-Inline
    %$IF MSIL;
     Cnt: TNDXB1
     Tbl: array[@.Cnt:Val] of TConstAddInfo01Rec
    %$END
    %$IF (Ver>=9)and IsDelphi;
     D: case @.F:Val and 0x80000 of
      0x80000: struc pas
       %$IF (Ver>=10)and IsDelphi;
         Y: TNDXB1
         Y1: TNDXB1
       %$END
         Len: TNDXB1
         D: array[@.Len:Val]of Byte
         X: array[5] of TNDXB1
         V2: TNDXB1 //Always 2=#1
         Len1: TNDXB1
         D1: array[@.Len1:Val]of struc pas
           Z: TNDXB1 //Always 0
           V: TNDXB1
           Z1: TNDXB1 //Always 0
          ends
         Len2: TNDXB1
         D2: array[@.Len2:Val]of struc pas
           V4: TNDXB1 //Always 4
           V: TNDXB1
          ends
         Len3: TNDXB1
         ImpData: array[@.Len3:Val]of struc pas
           hUnit: TNDXB1
           Len: TNDXB1
           D: array[@.Len:Val]of TNDXB1 //Imported def
          ends
       ends
     endc
     IP: case @.F:Val and 0x100000 of
      0x100000: struc pas
       %$IF (Ver>=10)and IsDelphi;
        Cnt: TNDXB1
        Tbl: array[@.Cnt:Val] of TNDXB1
       %$END
        V: TNDXB1 //Some int(4)
      ends
     endc
     %$IF (Ver>=10)and IsDelphi;
     IP1: case @.F:Val and 0x1000000 of
      0x1000000: TNDXB1 //Some int(4)
     endc
     %$END
    %$END
    ends
   %$IF (Ver>=10)and IsDelphi;
   0x04: struc pas
     V: TNDXB1
     V1: TNDXB1
    ends
   %$END
   0x06: struc pas
     hDef: TNDXB1
     hDT: TNDXB1
     V: TNDXB1
     hDef1: TNDXB1
    ends
   0x07: struc pas
     hDef: TNDXB1
     hDef1: TNDXB1
     hDef2: TNDXB1
     V: TNDXB1
    ends
   0x09: struc pas
     hDef: TNDXB1
     hDT: TNDXB1
    ends
   0x0A: struc pas
     hDef: TNDXB1
     V: TNDXB1
     F: TNDXB1
     hDT: case @.F:Val and 0x1 of
      0x1: TNDXB1
     endc
     hDef1: case @.F:Val and 0x2 of
      0x2: TNDXB1
     endc
     V2: case @.F:Val and 0x4 of
      0x4: TNDXB1
     endc
     V3: case @.F:Val and 0x8 of
      0x8: TNDXB1
     endc
     V4: case @.F:Val and 0x10 of
      0x10: TNDXB1
     endc
     hDef5: case @.F:Val and 0x20 of
      0x20: TNDXB1
     endc
     inf7: case @.F:Val and 0x40 of
      0x40: struc pas
        Cnt: TNDXB1
        Tbl: array[@.Cnt:Val] of TConstAddInfo0A_7Rec
       ends
     endc
     inf8: case @.F:Val and 0x80 of
      0x80: struc pas
        V: TNDXB1
        V1: TNDXB1
        V2: TNDXB1
       ends
     endc
     s9: case @.F:Val and 0x100 of
      0x100: TStrNDXB1
     endc
     s10: case @.F:Val and 0x200 of
      0x200: TStrNDXB1
     endc
     hDef11: case @.F:Val and 0x400 of
      0x400: TNDXB1
     endc
     hDef12: case @.F:Val and 0x800 of
      0x800: TNDXB1
     endc
     hDef13: case @.F:Val and 0x1000 of
      0x1000: TNDXB1
     endc
     hDef14: case @.F:Val and 0x2000 of
      0x2000: TNDXB1
     endc 
     hDef15: case @.F:Val and 0x4000 of
      0x4000: TNDXB1 //MSIL 9 only?
     endc 
    ends
   0x0C: struc pas
     hDef: TNDXB1
     V1: TNDXB1
     V2: TNDXB1
    ends
  %$IF (Ver>=9)and IsDelphi;
   0x0D: struc pas
     hDef: TNDXB1
     S: TStrNDXB1
    ends
  %$END
  endc
ends

%$IF (Ver>=9)and IsDelphi;
const
  caiStop=0x0F;
%$ELSE
const
  caiStop=0x0D;
%$END

type

TConstAddInfo array of TConstAddInfoRec ?@.Tag>=caiStop!byte; //= ==> Ok,> ==> Error

%$ELSE
TConstAddInfo struc pas
  B01: Byte
  Ndx: TNDXB1
  B02: Byte
  B06: Byte
ends
%$END

%$END

%$IF (Ver>=8)and IsDelphi;
 Tbyte1 byte():assert[@=1]
%$END


TProcArg struc pas
  Tag: TProcArgTag
  D: case @.Tag of
    arSetDeft: TSetDeftInfo
    arEmbeddedProcEnd: void //For Ver=5
//   %$IF (Ver>=7)and IsDelphi;
   %$IF gen7;
    TDCU30RecTag.drConstAddInfo: TConstAddInfo
   %$END
   %$IF (Ver>=8)and IsDelphi;
    TDCU30RecTag.drProcAddInfo: TNDXB1
    TDCU30RecTag.drEmbeddedProcStart: void
   %$END
%$IF (Ver>=10)and IsDelphi;
    arCopyDecl: TNDXB1 //index of the address to copy from
    0x80..0xA2,0xA4..0xFF: void
%$ELSE
    0x80..0xFF: void
%$END
   else struc pas
    Name: Str
    D: case @@@.Tag of
      arLocType: TTypeInf
      arProperty: TPropInfo
      arConst: TConstDef
      arLabel: struc pas
        X: TNDXB1
       %$IF (Ver>=8)and IsDelphi;
        Y: TNDXB1
       %$END
       ends 
      arMethod: struc pas
        Flags: TNDXB1 //public=0x2,protected=0x4,published=0xA,
          //default property=0x20,virtual=0x40,$80=dynamic
       %$IF (Ver>=8)and IsDelphi;
        X: TNDXB1
       %$END
        hDT: TNDXB1
        Ndx: TNDXB1
       %$IF MSIL; //(Ver>=8)and IsDelphi;
        B1: case (@.Ndx.V.0)exc 1 of
         0: void
         else
          try
           Is1:Tbyte1
           Els: void
          endt
         endc
       %$END
       %$IF (Ver>=7)and IsDelphi;
        hImp: TNDXB1
       %$ELSE
        hImp: case @@@.Name[0] of
         0: TNDXB1
        endc //for property P:X read Proc{Implemented in parent class}
       %$END
      ends
    %$IF (Ver>=7)and IsDelphi;
      arConstr,arDestr: struc pas
        Flags: TNDXB1 //public=0x2,protected=0x4,published=0xA,
          //default property=0x20,virtual=0x40,$80=dynamic
       %$IF (Ver>=8)and IsDelphi;
        X1: TNDXB1
       %$END
        hDT: TNDXB1
        Ndx: TNDXB1
        X: TNDXB1
      ends
    %$END
      else struc pas
        Flags: TNDXB1 //public=0x2,protected=0x4,published=0xA,
          //default property=0x20,virtual=0x40,$80=dynamic
       %$IF (Ver>=8)and IsDelphi;
        X: TNDXB1
       %$END
        hDT: TNDXB1
        Ndx: TNDXB1
      ends
    endc
   ends
  endc
ends:displ=('[',HEX(&@),']',@)

TProcArgList array of TProcArg ?@.Tag=TProcArgTag.arStop!Char;

//B0: TNDXB1//Byte
//Sz: TNDXB1

%$IF Ver=2;

TProcData struc pas
  hDTRes: TNDXB1
  Args: TProcArgList
ends

%$ELSE

TProcData struc pas
  VProc: TNDXB1//Byte
  hDTRes: TNDXB1
 %$IF (Ver>=8)and IsDelphi;
  X: TNDXB1
 %$END
  Args: TProcArgList
ends

%$END

/*
TProcDataD struc pas
  D: ulong
  Dat: TProcData
ends

TProcInf struc pas
  BProc: Byte
  D: case @.BProc of
    0: struc pas
        B0: Byte
        Vp: TNDXB1
      ends
    1: struc pas
        B0: Byte
        D: case @.B0 of
          3: TProcDataD
        else Word
        endc
      ends
    else TProcDataD
  endc
ends

TEmbeddedProcInf struc pas
//  Tag:TDCU30RecTag
//  Name: Str
  BProc: Byte
  D: case @.BProc of
    0: struc pas
        B0: Byte
        Vp: TNDXB1
      ends
    1: struc pas
        B0: Byte
        W: Word
      ends
    else TProcData
  endc
ends
*/

/*
TProcInf(NoName) struc pas
  BProc: Byte
  D: case @:NoName of
    1: case @@.BProc of
       0: struc pas
         B0: Byte
         Vp: TNDXB1
       ends
       1: struc pas
           B0: Byte
           B1: Byte
           Sz: TNDXB1
         ends
  %$IF Ver>=6;
       3: struc pas
           B0: Byte
           B2: Byte
           B1: Byte
           Sz: TNDXB1
         ends
  %$END
    endc
  else struc pas
     D1: case @@@.BProc of
       0: void
       1: struc pas
           B0: Byte
           D: case @.B0 and 1 of
             1: ulong
           endc
         ends
       else ulong
     endc
     Dat: TProcData
   ends
  endc
ends
*/

TProcInf(NoName) struc pas
  NF: TNameFDecl
  B0: TNDXB1//Byte
  Sz: TNDXB1
  D: case @:NoName of
    1: void
  else TProcData
  endc
ends

%$IF (Ver>=8)and IsDelphi;
TSysProcInf struc pas
//  NF: TNameFDecl
  B80: Byte
  H: TNDXB1
  B0: TNDXB1//Byte
  Sz: TNDXB1
//	  X: TNDXB1
  D: TProcData
ends
%$ELSE
TSysProcInf struc pas
  B80: Byte
  H: TNDXB1
ends
%$END

/*
TEmbeddedInf struc pas
  Tag:TDCU30RecTag
  Name: Str
  D: case @.Tag of
    drType: TTypeInf
    drTypeP: TTypePInf
    drVar,drThreadVar: TVarInf
    drVarC: TVarInf
    drProc: TProcInf((@@.Name[0]=0)or(@@.Name='.')) //TEmbeddedProcInf
    drSysProc: TSysProcInf
    drResStr: TVarInf //TResStrDef
  endc
ends

TEmbeddedList array of TEmbeddedInf ?
  /*@.Tag<>TDCU30RecTag.drProc*/
  @.Tag=TDCU30RecTag.drEmbeddedProcEnd!TDCU30RecTag;
*/

TEmbeddedList forward

//// DEFINITIONS

TTypeDefBase struc pas
  RTTISz: TNDXB1 //Size of RTTI for type, if available
  Sz: TNDXB1
  V: TNDXB1
 %$IF MSIL; //(Ver>=8)and IsDelphi;
  X: TNDXB1
  X1: TNDXB1
//  X2: TNDXB1
 %$ELSIF (Ver>=9)and IsDelphi;
  X: TNDXB1
 %$END
ends

%$IF (Ver>=8)and IsDelphi;
TTypeDefBase0 struc pas
  RTTISz: TNDXB1 //Size of RTTI for type, if available
  Sz: TNDXB1
  V: TNDXB1
ends
%$ELSE
TTypeDefBase0 TTypeDefBase
%$END

TParentInterfaceInf forward

TRecDefInf struc pas
  Base: TTypeDefBase
  B2: Byte
 %$IF MSIL;//(Ver>=8)and IsDelphi;
  X: TNDXB1
  I: TParentInterfaceInf
 %$ELSIF (Ver>=9)and IsDelphi;
  %$IF (Ver>=10)and IsDelphi;
  B1: Byte
  X0: TNDXB1
  %$END
  X: TNDXB1
 %$END
  Fields: TProcArgList
ends

TPtrDefInf struc pas
  Base: TTypeDefBase
  hRefDT: TNDXB1
ends

TRangeDefInf struc pas
  Base: TTypeDefBase
  hDTBase: TNDXB1
  Lo: TNDXB1
  Hi: TNDXB1
 %$IF (Ver>=8)and IsDelphi;
// %$ELSIF (Ver=8)and IsDelphi;
  B: TNDXB1
 %$ELSE
  B: Byte
 %$END
ends

TEnumDefInf struc pas
  Base: TTypeDefBase
  hDTBase: TNDXB1
  Ndx: TNDXB1
  Lo: TNDXB1
  Hi: TNDXB1
 %$IF (Ver>=8)and IsDelphi;
// %$ELSIF (Ver=8)and IsDelphi;
  B: TNDXB1
 %$ELSE
  B: Byte
 %$END
ends

TSetDefInf struc pas
  Base: TTypeDefBase
  BStart: Byte //0-based start byte number
  hDTBase: TNDXB1
ends

TFloatDefInf struc pas
  Base: TTypeDefBase
  B1: Byte
ends

TArrayDefInf struc pas
  Base: TTypeDefBase
  B1: Byte
  hDTNdx: TNDXB1
  hDTEl: TNDXB1
 %$IF MSIL; //(Ver>=8)and IsDelphi;
  X: TNDXB1
 %$END
ends

TShortStrDefInf struc pas
  Base: TTypeDefBase
  B1: Byte
  V: TNDXB1
  Ndx1: TNDXB1
ends

TFileDefInf struc pas
  Base: TTypeDefBase
  hBaseDT: TNDXB1
ends

TStringDefInf struc pas
  Base: TTypeDefBase
  B0: Byte
  B1: TNDXB1//Byte
  hBaseDT: TNDXB1
ends

TVariantDefInf struc pas
  Base: TTypeDefBase
%$IF Ver>2;
  B: byte
%$END
ends

%$IF Ver=2;

TProcTypeDefInf struc pas
  Base: TTypeDefBase
  hDTRes: TNDXB1
  Bj: TDCU30RecTag
  Args: case @.Bj of
    drEmbeddedProcStart: TProcArgList
  endc
ends

%$ELSE

TProcTypeDefInf struc pas
  Base: TTypeDefBase
  NDX0: TNDXB1//B0: Byte
  hDTRes: TNDXB1
 /* AddB: case @.B0 and 0x08 of
    0x08: Byte
  endc*/
  AddB: array of Char ?(@=106/*'j'*/)or(@=99/*'c'*/)!void;
  Bj: TDCU30RecTag
  Args: case @.Bj of
    drEmbeddedProcStart: TProcArgList
  endc
ends

%$END

TObjVMTDefInf struc pas
  Base: TTypeDefBase
  hObjDT: TNDXB1
  Ndx1: TNDXB1
 %$IF MSIL; //(Ver>=8)and IsDelphi;
  X2: TNDXB1
 %$END
ends

TObjDefInf struc pas
  Base: TTypeDefBase
  B03: Byte
  hParent: TNDXB1
  BFE: Byte
  Ndx1: TNDXB1
  B00: Byte
  Args: TProcArgList
ends

TParentInterfaceRec struc pas
  hIntf: TNDXB1
  Cnt: TNDXB1 //Member count
 %$IF MSIL; //(Ver>=8)and IsDelphi;
  Member: array[@.Cnt:Val] of struc pas
    N: TNDXB1
    hMember: TNDXB1
   ends
 %$END
 %$IF (Ver>=10)and IsDelphi;
   X1: TNDXB1
   X2: TNDXB1
 %$END
ends

TParentInterfaceInf struc pas
  ICnt: TNDXB1
  ITbl: array[@.ICnt:Val] of TParentInterfaceRec//Byte
ends

TClassDefInf struc pas
  Base: TTypeDefBase
  %$IF (Ver>=10)and IsDelphi;
  BX: byte//TNDXB1
  %$END
  hParent: TNDXB1
  InstBase: TTypeDefBase0
  VMCnt: TNDXB1//B00: Byte
  NdxFE: TNDXB1//BFE: Byte
  Ndx00a: TNDXB1//B00a: Byte
 %$IF (Ver>=8)and IsDelphi;
  B04: TNDXB1
 %$ELSE
  B04: Byte
 %$END
%$IF Ver>2;
/*
  B00b: Byte //always 0 or 2 and was 4 in CorbaObj.dcu
  DAdd: case @.B00b=0 of
      0: struc pas
        B0: Byte
        B1: Byte
       ends
    endc
*/
  I: TParentInterfaceInf
%$END
  Args: TProcArgList
ends

%$IF (Ver>=8)and IsDelphi;

TMetaClassDefInf struc pas
  Base: TTypeDefBase
  hParent: TNDXB1
  InstBase: TTypeDefBase0
  VMCnt: TNDXB1//B00: Byte
  NdxFE: TNDXB1//BFE: Byte
  Ndx00a: TNDXB1//B00a: Byte
 %$IF (Ver>=8)and IsDelphi;
  B04: TNDXB1
  %$IF (Ver>=10)and IsDelphi;
  BX: TNDXB1
  %$END
 %$ELSE
  B04: Byte
 %$END
%$IF Ver>2;
  hCl: TNDXB1  //Only this 2 fields are added in comparison with TClassDefInf
  X: TNDXB1    //
  I: TParentInterfaceInf
%$END
  Args: TProcArgList


ends

%$END

TGUID struc
  ulong D1
  word D2
  word D3
  array[8] of byte D4
ends

TInterfaceProcArg struc pas
  Tag: TProcArgTag
  D: case @.Tag and 0x80 of
    0x80: 
   %$IF gen7;
    case @@.Tag of
     TDCU30RecTag.drConstAddInfo: TConstAddInfo
    else void
    endc
   %$ELSE
    void
   %$END
   else struc pas
    Name: Str
    D: case @@@.Tag of
//      arLocType: TTypeInf
      arProperty: TPropInfo
      else struc pas
        Ndx1: TNDXB1
        hDT: TNDXB1
        NDXB: TNDXB1
        Ndx: TNDXB1
      %$IF (Ver>=8)and IsDelphi;
        B1: TNDXB1
      %$END
      ends
    endc
   ends
  endc
ends

TInterfaceProcArgList array of TInterfaceProcArg ?@.Tag=TProcArgTag.arStop!Char;

TDispInterfaceProcArg struc pas
  Tag: TProcArgTag
  D: case @.Tag and 0x80 of
    0x80:
   %$IF gen7;
    case @@.Tag of
     TDCU30RecTag.drConstAddInfo: TConstAddInfo
    else void
    endc
   %$ELSE
    void
   %$END
   else struc pas
    Name: Str
    D: struc pas
        Ndx1: TNDXB1
        hDT: TNDXB1
        NDXB: TNDXB1
        Ndx: TNDXB1
      %$IF (Ver>=8)and IsDelphi;
        B1: TNDXB1
      %$END
      ends
   ends
  endc
ends

TDispInterfaceProcArgList array of TDispInterfaceProcArg ?@.Tag=TProcArgTag.arStop!Char;

TInterfaceDefInf struc pas
  Base: TTypeDefBase
  hParent: TNDXB1
  VMCnt: TNDXB1
  GUID: TGUID
  B: Byte //02 for all interfaces, 06 for dispinterface
 %$IF (Ver>=8)and IsDelphi;
  Sz: TNDXB1
  D: array[@.Sz:Val] of struc pas
     X: TNDXB1
     Z: TNDXB1
   ends
 %$END
  Args: case @.B and 0x04 of
    0: TInterfaceProcArgList
  else TDispInterfaceProcArgList
  endc
ends


TCodeBlockInf struc pas
  Sz: TNDXB1
  D: raw[@.Sz:Val]
ends

TFixUpRec struc pas
  dOfs: TNDXB1 //From the start of the previous one
  B1: byte
  N2: TNDXB1
ends

TFixUpData struc pas
  Sz: TNDXB1
  D: array[@.Sz:Val] of TFixUpRec
ends

TCodeLinesRec struc pas
  dL: TNDXB1
  dOfs: TNDXB1
ends

TCodeLinesData struc pas
  Sz: TNDXB1
  D: array[@.Sz:Val] of TCodeLinesRec
ends

TLineRange struc pas
  Line0: TNDXB1
  LineNum: TNDXB1
  hFile: TNDXB1
ends

TLinNumData struc pas
  Sz: TNDXB1
  Ranges: array[@.Sz:Val] of TLineRange
ends

TStrucScopeRec struc pas //
  hType: TNDXB1
  hVar: TNDXB1 //<>0 for With
  Ofs: TNDXB1 //usually=0
  LnStart: TNDXB1 //1st member line
  LnCnt: TNDXB1 //total member lines
ends

TStrucScopeData struc pas
  Sz: TNDXB1
  D: array[@.Sz:Val] of TStrucScopeRec
ends

TSymbolRefRec struc pas
  hSym: TNDXB1
  hMember: TNDXB1 //for symbols - type members, else - 0
  Sz: TNDXB1
  hDef: TNDXB1 //index of symbol definition in the L array
  L: array[@.Sz:Val] of TNDXB1
ends

TSymbolRefData struc pas
  Sz: TNDXB1
  NPrimary: TNDXB1 //# of Not member definitions
  D: array[@.Sz:Val] of TSymbolRefRec
ends

%$IF Ver=3;
TUnitFlagsData struc pas
  Flags: TNDXB1 //0x500 - WEAKPACKAGEUNIT
ends
%$ELSIF Ver>3;
TUnitFlagsData struc pas
  Flags: TNDXB1 //0x500 - WEAKPACKAGEUNIT
%$IF (Ver>9)and(IsDelphi);
  Flags1: TNDXB1
%$END
  Priority: TNDXB1 //Always 0x1E
ends
%$END


TLocVarInf struc pas //DoDi's info
  sym: TNDXB1 //Symbol # in the symbol table, 0 - proc data end
  ofs: TNDXB1 //Offset in procedure code
  frame: TNDXB1 //-1(0x7f)-symbol end, else - symbol start 0-EAX, 1-EDX,
    //2-ECX, 3-EBX, 4-ESI...
ends

TLocVarTbl struc pas
  Sz: TNDXB1
  D: array[@.Sz:Val] of TLocVarInf
ends

%$IF (Ver>=7)and IsDelphi;
/*
TUnitAddInfo struc pas
  D: array of char,'c';
ends
%$ELSIF (Ver>=8)and IsDelphi;
*/
TUnitAddInfo struc pas
  NF: TNameFDecl
  B: TNDXB1
  Sub: TDCU30ListC
ends
%$END

%$IF (Ver>=8)and IsDelphi;
TORec struc pas
  B: TNDXB1
ends


TStrConstRec struc pas
//%$IF (Ver<10);
  NF: TNameFDecl
  V: TNDXB1
  hDT: TNDXB1
/*
%$ELSE
  NF: TNameFDecl
  hDT: TNDXB1
  L: Byte //drStop1='c' - some list
%$END
*/
ends
%$END


%$IF (Ver>=8)and IsDelphi;
TInfo98Rec struc pas
  B4: TNDXB1
  V: TNDXB1
ends
%$END


//Main Stream Record
TDCU30Rec struc pas
  Tag: TDCU30RecTag
  D: case @.Tag of
      drVoid: TTypeDefBase
      drRecDef: TRecDefInf
      drPtrDef: TPtrDefInf
      drRangeDef,drChRangeDef,drBoolRangeDef,drWCharRangeDef,
      drWideRangeDef: TRangeDefInf
      drEnumDef: TEnumDefInf
      drFloatDef: TFloatDefInf
      drSetDef: TSetDefInf
      drArrayDef: TArrayDefInf
      drShortStrDef: TShortStrDefInf
      drFileDef: TFileDefInf
      drTextDef: TTypeDefBase
      drStringDef,drWideStrDef: TStringDefInf
      drVariantDef: TVariantDefInf
      drProcTypeDef: TProcTypeDefInf
      drObjVMTDef: TObjVMTDefInf
      drObjDef: TObjDefInf
      drClassDef: TClassDefInf
 %$IF (Ver>=8)and IsDelphi;
      drMetaClassDef: TMetaClassDefInf
 %$END
      drInterfaceDef: TInterfaceDefInf
      drEmbeddedProcStart:TEmbeddedList
      drEmbeddedProcEnd: void
      drCBlock: TCodeBlockInf
      drFixUp: TFixUpData
      drCodeLines: TCodeLinesData
      drLinNum: TLinNumData
      drStrucScope: TStrucScopeData
      drSymbolRef: TSymbolRefData
      drLocVarTbl: TLocVarTbl
%$IF Ver>=3;
      drUnitFlags: TUnitFlagsData
%$END
/*
%$IF Ver>=100; //Kylix specific flags
      drUnit3,drUnit3s: array[3]of byte
      drUnit4: ulong
%$END
*/
     %$IF gen7;
       drConstAddInfo: TConstAddInfo
     %$END
     %$IF (Ver>=7)and IsDelphi;
       drProcAddInfo: TNDXB1//byte //=02
     %$END
      drSetDeft: TSetDeftInfo
     %$IF (Ver>=9)and IsDelphi;
      drStop2: ulong
     %$ELSE
      drStop2: void
     %$END
     %$IF (Ver>=8)and IsDelphi;
      drORec: TORec //goes before drCBlock
     %$END
     %$IF (Ver>=8)and IsDelphi;
      drInfo98: TInfo98Rec
     %$END
     %$IF (Ver>=10)and IsDelphi;
      drCLine: struc pas
        Cnt: TNDXB1
        Txt: array[@.Cnt:Val]of Char
       ends
      drA1Info: struc pas
        V0: TNDXB1
        V1: TNDXB1
        V2: TNDXB1
        V3: TNDXB1
        Cnt: TNDXB1
        Tbl: array[@.Cnt:Val]of TNDXB1
       ends
      drA2Info: void 
     %$END
     else struc pas
      Name: Str
      D: case @@@.Tag of
        drSrc, drObj, drAsm: TSrcInf
        drRes: TResInf
        drUnit,drUnit1: TUnitInf
        drDLL: TDllInf
        drType: TTypeInf
        drTypeP: TTypePInf
        drImpType,drImpVal: ulong
        drImpTypeDef: TImpTypeDefInf
        drExport: TExportInf
        drVar,drThreadVar: TVarInf
        drVarC: TVarInf
        drAbsVar: TVarInf
       /* drProc: TProcInf((@@.Name[0]=0)or(@@.Name='.')/* for Ver>=6 : */or
          (@@.Name='..'))*/
        drProc: TProcInf((@@.Name[0]=0)or(@@.Name[1]='.'))
        drSysProc: TSysProcInf
        drConst: TConstDef
        drResStr: TVarInf //TResStrDef
        drLabel: TNDXB1
       %$IF (Ver>=7)and IsDelphi;
        drUnitAddInfo: TUnitAddInfo
       %$END
       %$IF (Ver>=8)and IsDelphi;
        drStrConstRec: TStrConstRec
       %$END
       %$IF (Ver>=10)and IsDelphi;
       /* drStrConstRec
        drAddInfo6: struc pas
           V1: TNDXB1 //0
           Z1: TNDXB1 //0
           V2: TNDXB1 //0
           Z2: TNDXB1 //was<>0
         ends
       */
        drSpecVar: TVarInf
        /*
         struc pas
           V1: TNDXB1 //#23
           Z1: TNDXB1 //0
           V2: TNDXB1 //#17
           Z2: TNDXB1 //0
         ends
        */
       %$END
      endc
     ends
    endc
ends:displ=('[',HEX(&@),']',@)

TDCU30List0 array of TDCU30Rec ?((@.Tag<0x61/*'a'*/)and
  (@.Tag<>TDCU30RecTag.drType)and
  (@.Tag<>TDCU30RecTag.drTypeP)and
  (@.Tag<>TDCU30RecTag.drProc)and
  (@.Tag<>TDCU30RecTag.drSysProc)and
  (@.Tag<>TDCU30RecTag.drConst)and
  (@.Tag<>TDCU30RecTag.drResStr)and
  (@.Tag<>TDCU30RecTag.drVar)and
  (@.Tag<>TDCU30RecTag.drThreadVar)and
  (@.Tag<>TDCU30RecTag.drVarC)and
  (@.Tag<>TDCU30RecTag.drAbsVar)and
  (@.Tag<>TDCU30RecTag.drVoid)and
  (@.Tag<>TDCU30RecTag.drLabel)and
  (@.Tag<>TDCU30RecTag.drRecDef)and
  (@.Tag<>TDCU30RecTag.drPtrDef)and
  (@.Tag<>TDCU30RecTag.drRangeDef)and
  (@.Tag<>TDCU30RecTag.drChRangeDef)and
  (@.Tag<>TDCU30RecTag.drWCharRangeDef)and
  (@.Tag<>TDCU30RecTag.drBoolRangeDef)and
  (@.Tag<>TDCU30RecTag.drEnumDef)and
  (@.Tag<>TDCU30RecTag.drFloatDef)and
  (@.Tag<>TDCU30RecTag.drSetDef)and
  (@.Tag<>TDCU30RecTag.drArrayDef)and
  (@.Tag<>TDCU30RecTag.drShortStrDef)and
  (@.Tag<>TDCU30RecTag.drFileDef)and
  (@.Tag<>TDCU30RecTag.drTextDef)and
  (@.Tag<>TDCU30RecTag.drStringDef)and
  (@.Tag<>TDCU30RecTag.drWideStrDef)and
  (@.Tag<>TDCU30RecTag.drWideRangeDef)and
  (@.Tag<>TDCU30RecTag.drVariantDef)and
  (@.Tag<>TDCU30RecTag.drProcTypeDef)and
  (@.Tag<>TDCU30RecTag.drObjVMTDef)and
  (@.Tag<>TDCU30RecTag.drObjDef)and
  (@.Tag<>TDCU30RecTag.drClassDef)and
/*
%$IF Ver>=100; //Kylix specific flags
  (@.Tag<>TDCU30RecTag.drUnit4)and
  (@.Tag<>TDCU30RecTag.drUnit3s)and
%$END
*/
 %$IF (Ver>=7)and IsDelphi;
  (@.Tag<>TDCU30RecTag.drUnitAddInfo)and
 %$END
 %$IF (Ver>=8)and IsDelphi;
  (@.Tag<>TDCU30RecTag.drStrConstRec)and
  (@.Tag<>TDCU30RecTag.drMetaClassDef)and
 %$END
%$IF (Ver>=10)and IsDelphi;
//  (@.Tag<>TDCU30RecTag.drAddInfo6)and
  (@.Tag<>TDCU30RecTag.drSpecVar)and
%$END
  (@.Tag<>TDCU30RecTag.drInterfaceDef)
  or(@.Tag=TDCU30RecTag.drStop2)
  or(@.Tag=TDCU30RecTag.drStop_a)
  or(@.Tag>0x7A/*z*/)and
  (@.Tag<>TDCU30RecTag.drCodeLines)and
  (@.Tag<>TDCU30RecTag.drLinNum)and
  (@.Tag<>TDCU30RecTag.drStrucScope)and
  (@.Tag<>TDCU30RecTag.drSymbolRef)and
  (@.Tag<>TDCU30RecTag.drLocVarTbl)and
/*
%$IF Ver>=100; //Kylix specific flags
  (@.Tag<>TDCU30RecTag.drUnit3)and
%$END
*/
// %$IF (Ver>=7)and IsDelphi;
 %$IF gen7;
  (@.Tag<>TDCU30RecTag.drConstAddInfo)and
 %$END
 %$IF (Ver>=7)and IsDelphi;
  (@.Tag<>TDCU30RecTag.drProcAddInfo)and
 %$END
 %$IF (Ver>=8)and IsDelphi;
  (@.Tag<>TDCU30RecTag.drORec)and
 %$END
%$IF (Ver>=8)and IsDelphi;
  (@.Tag<>TDCU30RecTag.drInfo98)and
%$END
%$IF (Ver>=10)and IsDelphi;
  (@.Tag<>TDCU30RecTag.drCLine)and
  (@.Tag<>TDCU30RecTag.drA1Info)and
  (@.Tag<>TDCU30RecTag.drA2Info)and
%$END
  (@.Tag<>TDCU30RecTag.drUnitFlags)and
  (@.Tag<>TDCU30RecTag.drSetDeft)
)!TDCU30RecTag;

//TDCU30List0 array of TDCU30Rec ?(@.Tag=0)!Char;
//TDCU30List0 array[100] of TDCU30Rec

TDCU30ListC array of TDCU30Rec ?@.Tag=TDCU30RecTag.drStop1!TDCU30RecTag;
TEmbeddedList array of TDCU30Rec/*TEmbeddedInf*/ ?
  /*@.Tag<>TDCU30RecTag.drProc*/
  @.Tag=TDCU30RecTag.drEmbeddedProcEnd!TDCU30RecTag;

//Unit header record (version-dependent)

%$IF Ver=2;
//Delphi2
type

TDCUHeader struc pas
  FileSize: ulong
  CompileTime: TFileTime //L1: ulong
  b00: byte
  Tbl: TDCU30List0
ends//:[@:Size=FileSize]

%$ELSIF Ver=3;
//Delphi3
type

TDCUHeader struc pas
  FileSize: ulong
  CompileTime: TFileTime //L1: ulong
  Inf: ulong
  b00: byte
/*
  Tag1: TDCU30RecTag
//  b01: byte
//  Some: raw[@.b01]
  Flags: TNDXB1 //0x500 - WEAKPACKAGEUNIT
*/
  Tbl: TDCU30List0
ends//:[@:Size=FileSize]

%$ELSIF Ver=4;
//Delphi4
type

TDCUHeader struc pas
  FileSize: ulong
  CompileTime: TFileTime //L1: ulong
  Inf: ulong
  b00: byte
/*
  Tag1: TDCU30RecTag
//  b01: byte
//  Some: raw[@.b01]
  Flags: TNDXB1 //0x500 - WEAKPACKAGEUNIT
  Bx: Byte
*/
  Tbl: TDCU30List0
ends//:[@:Size=FileSize]

%$ELSIF Ver=5;
//Delphi5
type

TDCUHeader struc pas
  FileSize: ulong
  L1: ulong
  Inf: ulong
//  FT: TFileTime // L1: ulong
//  L2: ulong
  b00: byte
/*
  Tag1: TDCU30RecTag
//  b01: byte
//  Some: raw[@.b01]
  Flags: TNDXB1 //0x500 - WEAKPACKAGEUNIT
  Bx: Byte
*/
  Tbl: TDCU30List0
ends//:[@:Size=FileSize]

%$ELSIF Ver=6;
//Delphi6
type

TDCUHeader struc pas
  FileSize: ulong
  CompileTime: TFileTime //L1: ulong
  Inf: ulong
  b00: byte
  Tbl: TDCU30List0
ends//:[@:Size=FileSize]

%$ELSIF (Ver=7)or(Ver=8);
//Delphi7
type

TDCUHeader struc pas
  FileSize: ulong
  CompileTime: TFileTime //L1: ulong
  Inf: ulong
  b00: byte
  b02: byte
  Tbl: TDCU30List0
ends//:[@:Size=FileSize]

%$ELSIF (Ver=9)or(Ver=10);
//Delphi2005
type

TDCUHeader struc pas
  FileSize: ulong
  CompileTime: TFileTime //L1: ulong
  Inf: ulong
  b00: byte
  b02: byte
  Name: str
  Tbl: TDCU30List0
ends//:[@:Size=FileSize]

%$ELSIF Ver>=100;
//Kylix 1.0,2.0
type

TLXRec struc pas
  F: byte
  D: ulong
ends

/*
TLX0F array of TLXRec?@.F<>0x0F!void;:assert[@[0].F exc 0]
TLX try
  F: TLX0F
  ELS: ulong
endt
*/
TLX0F array of TLXRec?@.F<>0x0F!void;
TELS num+(4):assert[Byte(@)<>TDCU30RecTag.drUnitFlags]
TLX struc
  TLX0F X //This structure was observed in the file QOpenBanner.dcu
    //which displays Kylix nag screen and treated specially by
    //compiler
  try
    ELS: TELS
    NO: void
  endt ELS //Sometimes these 4 bytes are not present, and the 1st byte of
    //of them can have various values such as 0,0x12 or E0.
ends

TDCUHeader struc pas
  FileSize: ulong
  CompileTime: TFileTime //L1: ulong
  Inf: ulong
  b00: byte
  LX: TLX
  Tbl: TDCU30List0
ends//:[@:Size=FileSize]

%$END

data
  0x0004 TDCUHeader Hdr
